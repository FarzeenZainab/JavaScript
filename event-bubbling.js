'use strict';

///////////////////////////////////////
// Modal window

const modal = document.querySelector('.modal');
const overlay = document.querySelector('.overlay');
const btnCloseModal = document.querySelector('.btn--close-modal');
const btnsOpenModal = document.querySelectorAll('.btn--show-modal');

const openModal = function () {
  modal.classList.remove('hidden');
  overlay.classList.remove('hidden');
};

const closeModal = function () {
  modal.classList.add('hidden');
  overlay.classList.add('hidden');
};

for (let i = 0; i < btnsOpenModal.length; i++)
  btnsOpenModal[i].addEventListener('click', openModal);

btnCloseModal.addEventListener('click', closeModal);
overlay.addEventListener('click', closeModal);

document.addEventListener('keydown', function (e) {
  if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
    closeModal();
  }
});

console.log(document.documentElement);
console.log(document.head);
console.log(document.body);

document.querySelector('.header');
document.querySelectorAll('.section');

document.getElementById('section--1');
const allBtns = document.getElementsByTagName('button');
console.log(allBtns);

// Creating and inserting elements
const msg = document.createElement('div');
msg.classList.add('cookie-message');

// sets the text
msg.textContent = 'We use cookies to improve analytics';

// inserts html in the element
msg.innerHTML =
  'We use cookies to improve analytics. <button class="btn btn--close-cookie">Got it!</button>';

// So now, we have our element and we just have to insert it in our DOM
const header = document.querySelector('.header');

// adds the first child of the element
header.prepend(msg);

// add the last child of the element
header.append(msg);

// You can either append the element or prepend it. How to create multiple copies of the same element?
// We have to create a clone of the element that we have to append or prepend multiple times using .cloneNode method

// header.append(msg.cloneNode(true))

// .before and .after method
header.before(msg); // adds element before the header element
header.after(msg); // adds element after the header element

// removing element
const cookieBtn = document.querySelector('.btn--close-cookie');
cookieBtn.addEventListener('click', () => {
  msg.remove();
});

// Styles
msg.style.backgroundColor = '#37383d';
msg.style.width = '100%'; // these styles are set as inline styles.

console.log(msg.style.backgroundColor); // only gives styles that we set manually using JS

// getComputedStyle(): gives us the styles of the element from CSS
console.log(getComputedStyle(msg).color);
console.log(getComputedStyle(msg).height);

// add 40px to the current height of the element
const msgHeight = getComputedStyle(msg).height;
// msgHeight.style.height = msgHeight + '40px';

/*
  Types of event listeners
*/

// An event is a signal that is generated by a DOM node that means that something has happened. Ex: click, mouse moving. We can listen to these events using event listeners so we can handle them.

// Working with mouseenter event
const h1 = document.querySelector('h1');

// two ways of listening to events
// using .addEventListener | onEventName | inside html as attribute

// .addEventListener
// h1.addEventListener('mouseenter', () => alert('showing alert on mouse enter'));

// onEventName
h1.onmouseenter = function () {
  // alert('using on event listener');
}; // using this method we can not add multiple event listeners to the element because the new one will overwrite the previos one

// removing eventlistener
// the function should be exported to a named function if you want to remove it
const showOnce = function () {
  // alert('I will not bother you again');
  h1.removeEventListener('mouseenter', showOnce);
};

setTimeout(() => {
  h1.addEventListener('mouseenter', showOnce);
}, 3000); // remove event listener after 3 sec

/**
 * Event Propogation: Bubbling and capturing - practice
 */

// Event bubbling is a behavior in which an event that occurs on a specific element will also trigger the same event on its parent elements, one by one, all the way up to the root element of the document.

/**
 * Suppose you have a webpage with a button inside a div element, and the div element is inside a section
 * element, which is further inside a body element
 *
 * <body>
 *    <section>
 *      <div>
 *        <button>Click me!</button>
 *      </div>
 *    </section>
 * </body>
 *
 * Now let's say you click the button. When you click the button, the click event will be triggered for
 * the button itself. This is called the "target" element of the event
 *
 * But event bubbling does not stop there. After the button's click event is handled, the event will
 * "bubble up" to its parent element, in this case, the div element. If there is a click event listener
 * attached to the div element, it will also be triggered
 *
 * The bubbling continues to the next parent element, which is the section element. If there is a click
 * event listener attached to the section, it will be triggered as well
 *
 * Finally, the event reaches the top-most element, the body element, and if there is a click event
 * listener attached to it, it will also be triggered
 *
 * So, in event bubbling, the event propagates from the taret to its parent elements, one by one, until
 * it reaches the root element, triggering any event listeners along the way
 *
 * This bubbling behavior allows you to handle events at different levels of the document hierarchy.
 * It can be usful when you want to perform certain actions based on the event occurring on specific
 * elements or their ancestors
 *
 */

// rgb(255, 255, 255)
const randomInt = (min, max) =>
  Math.floor(Math.random() * (max - min + 1) + min);

/**
 * min 2
 * max 10
 * 3 * (10 - 2 + 1) + 2
 * 3 * 9 + 2 = 29
 */

const randomColor = () =>
  `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`;

// next, attach the event listener to the target element and to its parent element as well

// target element
document.querySelector('.nav__link').addEventListener('click', function (e) {
  this.style.backgroundColor = randomColor(0, 255);
});

// parent element of .nav__link
document.querySelector('.nav__links').addEventListener('click', function (e) {
  this.style.backgroundColor = randomColor(0, 255);
  //Expectation: onlu .nav__links background color should change but

  // we are clicking on .nav__link element but the color of parent element also changes on click that is because the event is bubbling up.
});

// parent element of .nav__links
document.querySelector('.nav').addEventListener('click', function (e) {
  this.style.backgroundColor = randomColor(0, 255);
});

// A simple way to understand event bubbling and propagation
/**
 * let's say your element is the living room.
 *
 * and its parent element is the whole house, okay?
 *
 * if you sit in the livingroom (your event),
 *
 * then you are sitting in your home, too. (again your event in the parent function).
 *
 * actually it is not so technical to guess.
 *
 * What I mean, when you do something in the child element, you have to do it in its parent element too
 * automatically. Because the parent contains the child. The child is just inside of it.
 */

// we can also stop the event propagation, which is not a good practice
